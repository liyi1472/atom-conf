"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("graceful-fs");
const path = require("path");
const readPackageJsonCB = require("read-package-json");
const ssri = require("ssri");
const promisify = require("util.promisify");
const parsePref_1 = require("./parsePref");
const readPackageJson = promisify(readPackageJsonCB);
/**
 * Resolves a package hosted on the local filesystem
 */
function resolveLocal(wantedDependency, opts) {
    return __awaiter(this, void 0, void 0, function* () {
        const spec = parsePref_1.default(wantedDependency.pref, opts.prefix);
        if (!spec)
            return null;
        if (spec.type === 'file') {
            return {
                id: spec.id,
                normalizedPref: spec.normalizedPref,
                resolution: {
                    integrity: yield getFileIntegrity(spec.fetchSpec),
                    tarball: spec.id,
                },
                resolvedVia: 'local-filesystem',
            };
        }
        let localPkg;
        try {
            localPkg = yield readPackageJson(path.join(spec.fetchSpec, 'package.json'));
        }
        catch (internalErr) {
            switch (internalErr.code) {
                case 'ENOTDIR': {
                    const err = new Error(`Could not install from "${spec.fetchSpec}" as it is not a directory.`);
                    err['code'] = 'ENOTPKGDIR'; // tslint:disable-line:no-string-literal
                    throw err;
                }
                case 'ENOENT': {
                    const err = new Error(`Could not install from "${spec.fetchSpec}" as it does not contain a package.json file.`);
                    err['code'] = 'ENOLOCAL'; // tslint:disable-line:no-string-literal
                    throw err;
                }
                default: {
                    throw internalErr;
                }
            }
        }
        return {
            id: spec.id,
            normalizedPref: spec.normalizedPref,
            package: localPkg,
            resolution: {
                directory: spec.dependencyPath,
                type: 'directory',
            },
            resolvedVia: 'local-filesystem',
        };
    });
}
exports.default = resolveLocal;
function getFileIntegrity(filename) {
    return __awaiter(this, void 0, void 0, function* () {
        return (yield ssri.fromStream(fs.createReadStream(filename))).toString();
    });
}
//# sourceMappingURL=index.js.map