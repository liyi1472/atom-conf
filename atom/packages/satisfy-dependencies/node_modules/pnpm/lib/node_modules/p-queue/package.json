{
  "_args": [
    [
      {
        "raw": "p-queue@^2.3.0",
        "scope": null,
        "escapedName": "p-queue",
        "name": "p-queue",
        "rawSpec": "^2.3.0",
        "spec": ">=2.3.0 <3.0.0",
        "type": "range"
      },
      "/home/zkochan/src/pnpm/pnpm/node_modules/@pnpm/package-requester"
    ]
  ],
  "_from": "p-queue@>=2.3.0 <3.0.0",
  "_id": "p-queue@2.4.2",
  "_inCache": true,
  "_location": "/p-queue",
  "_nodeVersion": "8.11.1",
  "_npmOperationalInternal": {
    "host": "s3://npm-registry-packages",
    "tmp": "tmp/p-queue_2.4.2_1525143344027_0.15245225953494557"
  },
  "_npmUser": {
    "name": "sindresorhus",
    "email": "sindresorhus@gmail.com"
  },
  "_npmVersion": "5.6.0",
  "_phantomChildren": {},
  "_requested": {
    "raw": "p-queue@^2.3.0",
    "scope": null,
    "escapedName": "p-queue",
    "name": "p-queue",
    "rawSpec": "^2.3.0",
    "spec": ">=2.3.0 <3.0.0",
    "type": "range"
  },
  "_requiredBy": [
    "/@pnpm/package-requester"
  ],
  "_resolved": "https://registry.npmjs.org/p-queue/-/p-queue-2.4.2.tgz",
  "_shasum": "03609826682b743be9a22dba25051bd46724fc34",
  "_shrinkwrap": null,
  "_spec": "p-queue@^2.3.0",
  "_where": "/home/zkochan/src/pnpm/pnpm/node_modules/@pnpm/package-requester",
  "author": {
    "name": "Sindre Sorhus",
    "email": "sindresorhus@gmail.com",
    "url": "sindresorhus.com"
  },
  "bugs": {
    "url": "https://github.com/sindresorhus/p-queue/issues"
  },
  "dependencies": {},
  "description": "Promise queue with concurrency control",
  "devDependencies": {
    "ava": "*",
    "benchmark": "^2.1.2",
    "delay": "^2.0.0",
    "in-range": "^1.0.0",
    "random-int": "^1.0.0",
    "time-span": "^2.0.0",
    "xo": "*"
  },
  "directories": {},
  "dist": {
    "integrity": "sha512-n8/y+yDJwBjoLQe1GSJbbaYQLTI7QHNZI2+rpmCDbe++WLf9HC3gf6iqj5yfPAV71W4UF3ql5W1+UBPXoXTxng==",
    "shasum": "03609826682b743be9a22dba25051bd46724fc34",
    "tarball": "https://registry.npmjs.org/p-queue/-/p-queue-2.4.2.tgz",
    "fileCount": 4,
    "unpackedSize": 10986,
    "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJa59cwCRA9TVsSAnZWagAAYHMQAJB4dTb2+xF2pcFPlu/I\nsHHfRBvKMvJBVIzLMVa2cPQa/daMGT0Vdh7p2o69rKZ97s662Yu6lWNOh7ee\nWe4wBXiH0I8axu1zC/j3qaCT1+mqYYB8WjcR4Z/yYhEq6nATo3Ex+kKZV3DF\nqS3wi6ANB+iWwOQ5TDHxXRe1Sqja7VxxzLPUYKFQWEjW1IzyT6Umx904pfa0\nsmcXziR0CvSpFuKKSuAB0r7nfeFll6k60bTfRClhtWnQIJYEkU1K6cz3VMZb\nECSiKEhKbBolHyRtd4tlYanpM9g8FrMkAJvtMXFiML8dyyoxUKPaf++0Rdxy\nOFMWUQiHKuV5DZCpa+L3V8PaK6yM7Z6lub6hsl8k8nsAPZGCfCnb8K0QtOTg\nyfVDi9HJSIkuAVHu6etglHCJAkslXeO4l8ukAA/dNXgNtpVlQTe2gKiOJq2z\nWzeIU9JcrAo4sgtj7wL0Ks0F1y2Y1M3ES6iPuVicgJuEeIKjf7NOk39Ya5oq\nTWzxfopM5b2y91ESre7bhqlW5GDm/ZcaHlj7XNUWaFuojCCb4nlb+88nRlT4\nHubgStfi2PmRdfuGzibHKpryvOX+hIbTw+3DyUozfsCM+YWiCp9ELC6Gfjcj\nwGUSuuJ59/Ai5ZLhG7WRoNrfP738ct6v+QorT8TOkiIh6Lj0r/NVkDQqEIVg\nlOl7\r\n=nHaW\r\n-----END PGP SIGNATURE-----\r\n"
  },
  "engines": {
    "node": ">=4"
  },
  "files": [
    "index.js"
  ],
  "gitHead": "a202b25d3e2f8d0472f85d501f7f558a7fa89b56",
  "homepage": "https://github.com/sindresorhus/p-queue#readme",
  "keywords": [
    "promise",
    "queue",
    "enqueue",
    "limit",
    "limited",
    "concurrency",
    "throttle",
    "throat",
    "rate",
    "batch",
    "ratelimit",
    "priority",
    "priorityqueue",
    "fifo",
    "job",
    "task",
    "async",
    "await",
    "promises",
    "bluebird"
  ],
  "license": "MIT",
  "maintainers": [
    {
      "name": "Vsevolod Strukchinsky",
      "email": "floatdrop@gmail.com",
      "url": "github.com/floatdrop"
    }
  ],
  "name": "p-queue",
  "optionalDependencies": {},
  "readme": "# p-queue [![Build Status](https://travis-ci.org/sindresorhus/p-queue.svg?branch=master)](https://travis-ci.org/sindresorhus/p-queue)\n\n> Promise queue with concurrency control\n\nUseful for rate-limiting async (or sync) operations. For example, when interacting with a REST API or when doing CPU/memory intensive tasks.\n\n\n## Install\n\n```\n$ npm install p-queue\n```\n\n\n## Usage\n\nHere we run only one promise at the time. For example, set `concurrency` to 4 to run four promises at the time.\n\n```js\nconst PQueue = require('p-queue');\nconst got = require('got');\n\nconst queue = new PQueue({concurrency: 1});\n\nqueue.add(() => got('sindresorhus.com')).then(() => {\n\tconsole.log('Done: sindresorhus.com');\n});\n\nqueue.add(() => got('ava.li')).then(() => {\n\tconsole.log('Done: ava.li');\n});\n\ngetUnicornTask().then(task => queue.add(task)).then(() => {\n\tconsole.log('Done: Unicorn task');\n});\n```\n\n\n## API\n\n### PQueue([options])\n\nReturns a new `queue` instance.\n\n#### options\n\nType: `Object`\n\n##### concurrency\n\nType: `number`<br>\nDefault: `Infinity`<br>\nMinimum: `1`\n\nConcurrency limit.\n\n##### autoStart\n\nType: `boolean`<br>\nDefault: `true`\n\nWhether queue tasks within concurrency limit, are auto-executed as soon as they're added.\n\n##### queueClass\n\nType: `Function`\n\nClass with a `enqueue` and `dequeue` method, and a `size` getter. See the [Custom QueueClass](#custom-queueclass) section.\n\n### queue\n\n`PQueue` instance.\n\n#### .add(fn, [options])\n\nAdds a sync or async task to the queue. Always returns a promise.\n\n##### fn\n\nType: `Function`\n\nPromise-returning/async function.\n\n#### options\n\nType: `Object`\n\n##### priority\n\nType: `number`<br>\nDefault: `0`\n\nPriority of operation. Operations with greater priority will be scheduled first.\n\n#### .addAll(fns, [options])\n\nSame as `.add()`, but accepts an array of sync or async functions and returns a promise that resolves when all functions are resolved.\n\n#### .pause()\n\nPut queue execution on hold.\n\n#### .start()\n\nStart (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via `options.autoStart = false` or by `.pause()` method.)\n\n#### .onEmpty()\n\nReturns a promise that settles when the queue becomes empty.\n\nCan be called multiple times. Useful if you for example add additional items at a later time.\n\n#### .onIdle()\n\nReturns a promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.\n\nThe difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.\n\n#### .clear()\n\nClear the queue.\n\n#### .size\n\nSize of the queue.\n\n#### .pending\n\nNumber of pending promises.\n\n#### .isPaused\n\nWhether the queue is currently paused.\n\n## Advanced example\n\nA more advanced example to help you understand the flow.\n\n```js\nconst delay = require('delay');\nconst PQueue = require('p-queue');\n\nconst queue = new PQueue({concurrency: 1});\n\ndelay(200).then(() => {\n\tconsole.log(`8. Pending promises: ${queue.pending}`);\n\t//=> '8. Pending promises: 0'\n\n\tqueue.add(() => Promise.resolve('üêô')).then(console.log.bind(null, '11. Resolved'));\n\n\tconsole.log('9. Added üêô');\n\n\tconsole.log(`10. Pending promises: ${queue.pending}`);\n\t//=> '10. Pending promises: 1'\n\n\tqueue.onIdle().then(() => {\n\t\tconsole.log('12. All work is done');\n\t});\n});\n\nqueue.add(() => Promise.resolve('ü¶Ñ')).then(console.log.bind(null, '5. Resolved'));\nconsole.log('1. Added ü¶Ñ');\n\nqueue.add(() => Promise.resolve('üê¥')).then(console.log.bind(null, '6. Resolved'));\nconsole.log('2. Added üê¥');\n\nqueue.onEmpty().then(() => {\n\tconsole.log('7. Queue is empty');\n});\n\nconsole.log(`3. Queue size: ${queue.size}`);\n//=> '3. Queue size: 1`\nconsole.log(`4. Pending promises: ${queue.pending}`);\n//=> '4. Pending promises: 1'\n```\n\n```\n$ node example.js\n1. Added ü¶Ñ\n2. Added üê¥\n3. Queue size: 1\n4. Pending promises: 1\n5. Resolved ü¶Ñ\n6. Resolved üê¥\n7. Queue is empty\n8. Pending promises: 0\n9. Added üêô\n10. Pending promises: 1\n11. Resolved üêô\n12. All work is done\n```\n\n\n## Custom QueueClass\n\nFor implementing more complex scheduling policies, you can provide a QueueClass in the options:\n\n```js\nclass QueueClass {\n\tconstructor() {\n\t\tthis._queue = [];\n\t}\n\tenqueue(run, options) {\n\t\tthis._queue.push(run);\n\t}\n\tdequeue() {\n\t\treturn this._queue.shift();\n\t}\n\tget size() {\n\t\treturn this._queue.length;\n\t}\n}\n```\n\n`p-queue` will call corresponding methods to put and get operations from this queue.\n\n\n## Related\n\n- [p-limit](https://github.com/sindresorhus/p-limit) - Run multiple promise-returning & async functions with limited concurrency\n- [p-throttle](https://github.com/sindresorhus/p-throttle) - Throttle promise-returning & async functions\n- [p-debounce](https://github.com/sindresorhus/p-debounce) - Debounce promise-returning & async functions\n- [p-all](https://github.com/sindresorhus/p-all) - Run promise-returning & async functions concurrently with optional limited concurrency\n- [More‚Ä¶](https://github.com/sindresorhus/promise-fun)\n\n\n## Created by\n\n- [Sindre Sorhus](https://github.com/sindresorhus)\n- [Vsevolod Strukchinsky](https://github.com/floatdrop)\n\n\n## License\n\nMIT ¬© [Sindre Sorhus](https://sindresorhus.com)\n",
  "readmeFilename": "readme.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/sindresorhus/p-queue.git"
  },
  "scripts": {
    "bench": "node bench.js",
    "test": "xo && ava"
  },
  "version": "2.4.2"
}
