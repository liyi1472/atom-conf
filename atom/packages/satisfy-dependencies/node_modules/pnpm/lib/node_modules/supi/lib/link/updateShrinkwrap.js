"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const dp = require("dependency-path");
const get_npm_tarball_url_1 = require("get-npm-tarball-url");
const pnpm_shrinkwrap_1 = require("pnpm-shrinkwrap");
const R = require("ramda");
const shrinkwrap_1 = require("../fs/shrinkwrap");
function default_1(depGraph, shrinkwrap, pkg) {
    shrinkwrap.packages = shrinkwrap.packages || {};
    for (const depPath of R.keys(depGraph)) {
        const relDepPath = dp.relative(shrinkwrap.registry, depPath);
        const result = R.partition((child) => depGraph[depPath].optionalDependencies.has(depGraph[child.depPath].name), R.keys(depGraph[depPath].children).map((alias) => ({ alias, depPath: depGraph[depPath].children[alias] })));
        shrinkwrap.packages[relDepPath] = toShrDependency(depGraph[depPath].additionalInfo, {
            depGraph,
            depPath,
            dev: depGraph[depPath].dev,
            id: depGraph[depPath].id,
            name: depGraph[depPath].name,
            optional: depGraph[depPath].optional,
            prepare: depGraph[depPath].prepare,
            prevResolvedDeps: shrinkwrap.packages[relDepPath] && shrinkwrap.packages[relDepPath].dependencies || {},
            prevResolvedOptionalDeps: shrinkwrap.packages[relDepPath] && shrinkwrap.packages[relDepPath].optionalDependencies || {},
            prod: depGraph[depPath].prod,
            registry: shrinkwrap.registry,
            relDepPath,
            requiresBuild: depGraph[depPath].requiresBuild,
            resolution: depGraph[depPath].resolution,
            updatedDeps: result[1],
            updatedOptionalDeps: result[0],
            version: depGraph[depPath].version,
        });
    }
    return pnpm_shrinkwrap_1.prune(shrinkwrap, pkg);
}
exports.default = default_1;
function toShrDependency(pkg, opts) {
    const shrResolution = toShrResolution({ name: opts.name, version: opts.version }, opts.relDepPath, opts.resolution, opts.registry);
    const newResolvedDeps = updateResolvedDeps(opts.prevResolvedDeps, opts.updatedDeps, opts.registry, opts.depGraph);
    const newResolvedOptionalDeps = updateResolvedDeps(opts.prevResolvedOptionalDeps, opts.updatedOptionalDeps, opts.registry, opts.depGraph);
    const result = {
        resolution: shrResolution,
    };
    // tslint:disable:no-string-literal
    if (dp.isAbsolute(opts.relDepPath)) {
        result['name'] = opts.name;
        // There is no guarantee that a non-npmjs.org-hosted package
        // is going to have a version field
        if (opts.version) {
            result['version'] = opts.version;
        }
    }
    if (!R.isEmpty(newResolvedDeps)) {
        result['dependencies'] = newResolvedDeps;
    }
    if (!R.isEmpty(newResolvedOptionalDeps)) {
        result['optionalDependencies'] = newResolvedOptionalDeps;
    }
    if (opts.dev && !opts.prod) {
        result['dev'] = true;
    }
    else if (opts.prod && !opts.dev) {
        result['dev'] = false;
    }
    if (opts.optional) {
        result['optional'] = true;
    }
    if (opts.depPath !== opts.id) {
        result['id'] = opts.id;
    }
    if (pkg.peerDependencies) {
        result['peerDependencies'] = pkg.peerDependencies;
    }
    if (pkg.engines) {
        for (const engine of R.keys(pkg.engines)) {
            if (pkg.engines[engine] === '*')
                continue;
            result['engines'] = result['engines'] || {};
            result['engines'][engine] = pkg.engines[engine];
        }
    }
    if (pkg.cpu) {
        result['cpu'] = pkg.cpu;
    }
    if (pkg.os) {
        result['os'] = pkg.os;
    }
    if (pkg.bundledDependencies || pkg.bundleDependencies) {
        result['bundledDependencies'] = pkg.bundledDependencies || pkg.bundleDependencies;
    }
    if (pkg.deprecated) {
        result['deprecated'] = pkg.deprecated;
    }
    if (opts.requiresBuild) {
        result['requiresBuild'] = opts.requiresBuild;
    }
    if (opts.prepare) {
        result['prepare'] = opts.prepare;
    }
    // tslint:enable:no-string-literal
    return result;
}
// previous resolutions should not be removed from shrinkwrap
// as installation might not reanalize the whole dependency graph
// the `depth` property defines how deep should dependencies be checked
function updateResolvedDeps(prevResolvedDeps, updatedDeps, registry, depGraph) {
    const newResolvedDeps = R.fromPairs(updatedDeps
        .map((dep) => {
        const depNode = depGraph[dep.depPath];
        return [
            dep.alias,
            shrinkwrap_1.absolutePathToRef(depNode.absolutePath, {
                alias: dep.alias,
                realName: depNode.name,
                resolution: depNode.resolution,
                standardRegistry: registry,
            }),
        ];
    }));
    return R.merge(prevResolvedDeps, newResolvedDeps);
}
function toShrResolution(pkg, relDepPath, resolution, registry) {
    // tslint:disable:no-string-literal
    if (dp.isAbsolute(relDepPath) || resolution.type !== undefined || !resolution['integrity']) {
        return resolution;
    }
    const base = registry !== resolution['registry'] ? { registry: resolution['registry'] } : {};
    // Sometimes packages are hosted under non-standard tarball URLs.
    // For instance, when they are hosted on npm Enterprise. See https://github.com/pnpm/pnpm/issues/867
    // Or in othere weird cases, like https://github.com/pnpm/pnpm/issues/1072
    if (get_npm_tarball_url_1.default(pkg.name, pkg.version, { registry }) !== resolution['tarball']) {
        return Object.assign({}, base, { integrity: resolution['integrity'], tarball: relativeTarball(resolution['tarball'], registry) });
    }
    return Object.assign({}, base, { integrity: resolution['integrity'] });
    // tslint:enable:no-string-literal
}
function relativeTarball(tarball, registry) {
    if (tarball.substr(0, registry.length) === registry) {
        return tarball.substr(registry.length - 1);
    }
    return tarball;
}
//# sourceMappingURL=updateShrinkwrap.js.map